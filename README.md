# stydy.github.io
1. NodeJS 장단점
   - 장점
     - 단일 스레드의 논 블로킹 이벤트 기반 비동식 방식으로 처리되어 높은 처리 성능을 가지고 있다.
     - 내장 HTTP 서버 라이브러리를 포함하고 있어 웹 서버에서 아파치 등의 별도의 소프트웨어 없이 동작하는 것이 가능하며 이를 통해 웹 서버의 동작에 있어 더 많은 통제를 가능하게 한다.
     - Javascript 언어로 프론트엔드 뿐만 아니라 백엔드 개발 환경을 구성할 수 있기에 생산성이 높고 러닝커브가 줄어든다.
     - 다양한 패키지 매니저를 기반으로 다양한 모듈을 제공하며 필요 라이브러리에 대해 설치하고 사용할 수 있기에 효율성이 좋다.
   - 단점
      - 비동기 기반의 처리 방식이라 서버의 로직이 복잡한 경우에 콜백 함수 늪에 빠질 수 있다.
      - 단일 스레드이기 때문에 하나의 작업이 오래 걸리는 웹 서비스에 경우 애플리케이션의 성능이 저하될 수 있다.
      - 해당 코드를 수행이 되어야 코드에서 에러가 났는지 확인이 가능하며 에러가 날 경우 프로세스 자체가 내려갈 수 있다.
      - 세션을 공유할 경우 redis와 같은 부가적인 인프라가 필요하다.

2. NodeJS 컨셉
   - 병렬적으로 처리되는 특징을 가지고 있습니다. 따라서 작업의 시간이 짧으며 요청이 많이 들어오는 시스템, 채팅서비스나 실시간으로 데이터를 보여주는 차트를 활용한 프로젝트 등을 개발할 경우 Node.js를 사용하시는 것이 좋습니다. 또한, JSON 형식의 데이터를 쉽게 처리할 수 있어 api 서버를 만드는데 용이하게 사용될 수 있습니다.
     
3. NodeJS 이벤트 루프
   - 블로그를 찾아 보았지만 아직 이해력이 부족.. 좀더 공부하고 정리하는것으로 ..
  
   ***

Q. 단일 스레드 / 멀티 스레드란 무엇인가?
A. 단일 스레드란 하나의 프로세스에서 하나의 스레드 실행, 멀티스레드란 하나의 프로세스에서 다수의 스레드 실행.
 - 프로세스 : 컴퓨에서 실행 중인 프로그램이며, 운영체제로부터 자원을 할당받은 작업의 단위이다.
 - 스레드 개념 : 스레드는 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위이다.

Q. 동기 / 비동기 방식이란 무엇인가? 
A. 동기 작업은 요청한 작업에 대해 순서가 지켜지는 것을 말하는것이고, 비동기 작업은 순서가 지켜지지 않을 수 있다는 것이다.


Q. 동기/비동기 와 블로킹/논블로킹 차이는?
A. 동기/비동기는 요청한 작업에 대해 완료 여부를 신경써서 작업을 순차적으로 수행할지 아닌지에 대한 관점이고, 
블로킹/논블로킹은 현재 작업이 block(차단,대기) 되느냐 아니냐에 따라 다른 작업을 수행하 수 있는지에 대한 관점이다.
- 비동기와 논 블로킹 차이
  <pre>
     console.log("시작");

     setTimeout(() => {
        console.log("1초 후에 실행됩니다!");
     }, 1000);

     console.log("끝");
  </pre>

  [결과]

  시작

  끝

  1초 후에 실행됩니다.

즉, 출력 순서와 정의된 코드 라인 순서가 맞지 않는것이다.  이는 setTimeout 함수에 대해 타이머 작업 완료 여부를 신경 쓰지 않고 바로 그 다음 콘솔 작업을 수행하였기 때문이다. 그리고 setTimeout 함수의 타이머 작업 완료 알람을 콜백 함수를 통해 값을 받아 출력하였다. 따라서 setTimeout 은 비동기(Asynchronouse)이다.


다른 시각으로 보면 메인 함수 작업에 대해서 setTimeout 함수는 자신의 타이머 작업을 수행하기 위해 메인 함수를 블락하지 않고 백그라운드에서 별도로 처리되었다. 메인 함수를 블락하지 않으니 setTimeout 함수를 호출하고 바로 그 다음 콘솔 함수를 호출한 것이다. 따라서 setTimeout 은 논블로킹(Non-blocking)이다.

결론.. 시점과 관련된 이론적인 개념이라 실제 코드에서 경계를 구분하기가 애매...

Q. 동기/비동기 + 블로킹/논블로킹 조합 알아보기
1. Sync Blocking (동기 + 블로킹)
- 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고, 다른 작업의 완료 여부를 바로 받아 순차적으로 처리하는 방식
- 일반적으로 작업이 간단하거나 작업량이 적은 경우 사용된다.
- ex) 간단한 파일을 읽어 내용을 처리하는 로직 , c나 java로 코드 실행 후 커맨드에서 입력을 받는 경우
    
2. Async Non-Blocking (비동기 + 논블로킹)
- 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고, 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식
- 작업량이 많거나 오래걸리는 작업을 처리하는 경우 적합
- ex) 웹 브라우저의 파일 다운로드 하면서 웹서핑하는 경우
    
3. Sync Non-Blocking (동기 + 논블로킹)
- 다른 작업이 진행되는 동안 자신의 작업을 처리하고, 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행하는 방식
- 흔하지 않는 케이스지만, 게임 로딩 화면(맵이동시 맵 데이터를 모두 다운 받는경우 로딩 스크린이 뜬다. 자신의 작업을 계속 하고 있지만 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회하는 것)
     
4. Async Blocking (비동기 + 블로킹)
- 다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리고, 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 방식
- 실무에서 잘 마주하지 않는 경우라고 함.
- 동기 블로킹 방식과 성능적으로 큰 차이가 없다고 함.
   
Q. 이벤트 루프란?
- https://www.youtube.com/watch?v=8aGhZQkoFbQ
- 브라우저의 동작 타이밍을 제어하는 관리자
- 브라우저 내부의 Call Stack, Callback Queue, Web APIs 등의 요소들을 모니터링하면서 비동기적으로 실행되는 작업들을 관리하고, 이를 순서대로 처리하여 프로그램의 실행 흐름을 제어하는 해준다.
- 이벤트 동작 과정
  - 자바스크립트의 setTimeout 이나 fetch와 같은 비동기 자바스크립트 코드를 브라우저 Web APIs에게 맡기고, 백그라운드 작업이 끝난 결과를 콜백 함수 형태로 큐(Callback Queue)에 넣고 처리 준비가 되면 호출 스택(Call Stack)에 넣어 마무리 작업을 진행한다.

***

Q. 함수 선언식이란?
- function 키워드로 시작하고 함수 이름을 명시한다.
- 함수가 선언된기 전에도 호출할 수 있다. --> 호이스팅
<pre>
   console.log(greet()); // "hello world"

   function greet() {
      return "hello world";
   }
</pre>

Q. 함수 표현식이란?
- 변수에 함수를 할당하는 형태로 작성된다.
- 호이스팅이 되지 않으며, 선언되기 전에는 호출할 수 없다.
<pre>
   console.log(greetExpr()); // TypeError: greetExpr is not a function

   var greetExpr = function() {
      return "hello world";
   };
</pre>

Q. 호이스팅이란?
- 함수의 선언부가 최상단으로 이동하는 것
- val 과 let 차이 (=var의 문제점)
  - val은 호이스팅이 되어 변수의 선언과 초기화 같이 시켜버림..
  - 에러를 뱉지 않고 undefined를 출력한다.
    <pre>
       console.log(a); //undefined
       var a = 1;
       console.log(a);
    </pre>
  - 함수만 지역변수로 호이스팅이 되고 나머지(for문, if문 지역변수)는 전역변수이다.
  - 같은 이름 변수 허용함.
  
